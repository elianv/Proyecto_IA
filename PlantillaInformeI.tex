\documentclass[letter, 10pt]{article}
\usepackage{enumerate}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage[dvips]{graphicx}
\usepackage{url}
\usepackage[top=3cm,bottom=3cm,left=3.5cm,right=3.5cm,footskip=1.5cm,headheight=1.5cm,headsep=.5cm,textheight=3cm]{geometry}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{algpseudocode}
%\input{spanishAlgorithmic} % mi archivo de traducci√≥n


\begin{document}
\title{Inteligencia Artificial \\ \begin{Large}Estado del Arte: Vehicle Routing Problem \emph{(VRP)}\end{Large}}
\author{Elian Vallejos}
\date{07 de Junio de 2014}
\maketitle


%--------------------No borrar esta secci\'on--------------------------------%
\section*{Evaluaci\'on}

\begin{tabular}{ll}
Mejoras 1ra Entrega (10 \%): &  \underline{\hspace{2cm}}\\
C\'odigo Fuente (10 \%): &  \underline{\hspace{2cm}}\\
Representaci\'on (15 \%):  & \underline{\hspace{2cm}} \\
Descripci\'on del algoritmo (20 \%):  & \underline{\hspace{2cm}} \\
Experimentos (10 \%):  & \underline{\hspace{2cm}} \\
Resultados (10 \%):  & \underline{\hspace{2cm}} \\
Conclusiones (20 \%): &  \underline{\hspace{2cm}}\\
Bibliograf\'ia (5 \%): & \underline{\hspace{2cm}}\\
 &  \\
\textbf{Nota Final (100)}:   & \underline{\hspace{2cm}}
\end{tabular}
%---------------------------------------------------------------------------%
\vspace{2cm}


\begin{abstract}
Lo que se pretende presenta en el siguiente documento, es el problema \emph{Vehicle Routing Problem}.
\newline
Este problema es una variante del conocido \emph{Traveling Salesmen Problem (TSP)}, lo que aqu\'i se quiere realizar,
es satisfacer la demanda de los clientes, entregando se mercader\'ia, minimizando los costos asociados a las rutas de entrega. Para 
esto se cuenta con una flota de veh\'iculos, los que son todos homog\'eneos. Adem\'as de realizar la entrega, los veh\'iculos deben volver 
al punto de origen, o sea a su dep\'osito. Lo m\'as importante en esta problem\'atica es poder satisfacer la necesidad de los clientes,
teniendo en cuenta los recursos con los cuales se cuenta, dado que no hay muchas variables en el problema, no es necesario ahondar m\'as
en esto.
A continuaci\'on se proceder\'a a definir el problema y buscar un m\'etodo que logre obtener una soluci\'on 
mas cercana al \'optimo. Para esto, se presentara un planteamiento formal, estado del arte del problema, posibles m\'etodos 
de soluci\'on y descripci\'on del modelo matem\'atico elegido.

\end{abstract}
\newpage

\section{Introducci\'on}

\emph{Vehicle Routing Problem (VRP)}, es un problema actual que comprenden todas aquellas empresas de reparto, La tarea de organizar las flotas
de veh\'iculos. La tarea de minimizar los costos asociados a las entregas, sin desmerecer los tiempos y satisfacci\'on de los clientes, es un desaf\'io
complejo para la log\'istica y una problem\'atica dif\'icilmente de resolver.
\newline
Antes de ir m\'as alla, cabe destacar de que este es un problema que nace del TSP (\emph{Traveling Salesman Problem}), dado que este es el problema
m\'as simple de abordar lo que se presentara aqu\'i es una variable de este, pero en sus principios y bases son iguales~\cite{TSP}.
\newline
Actualmente el mejoramiento y la optimizaci\'on en los procesos de distribuci\'on trae consigo grandes ahorros, dado que antiguamente no era una
problem\'atica tan compleja como es en los d\'ias de hoy. El problema ha ido evolucionando hasta encontrar las distintas variantes, inclusive la 
mezcla de cada una de ellas conlleva una aproximaci\'on a lo que es el mundo real de hoy en d\'ia. Para comprender el significado de esto,
es que a trav\'es de los distintos temas abarcados en este Paper, se conocer\'an las variables que existen, junto con su explicaci\'on y que diferencia
tienen entre ellos. Se entregara una visi\'on actual del problema, cuales son los algoritmos que se utilizan actualmente~\cite{Prosser93Hybrid}, no se explican t\'ecnicas 
completas, dado que estas no son utilizadas en plenitud en la actualidad debido al tiempo de computo que necesitan para resolver, es por esto que se usan 
t\'ecnicas incompletas de resoluci\'on, para as\'i tener en un tiempo aceptable, soluciones de buena calidad.
Como se trata de un problema matem\'atico, se dar\'a a conocer su modelo, adem\'as de las restricci\'on que este implica, su funci\'on de evaluaci\'on,
y las constantes o par\'ametros que se tienen que considerar.
\newline
Algo para tener en cuenta, es que la motivaci\'on que persigue esto, es la necesidad de comprender mas en profundidad y con problemas reales, la 
problem\'atica que se enfrenta al implementar soluciones para esta clase de problemas y tener un contraste entre lo que se aprende en un aula, junto
con lo que se aprende en la investigaci\'on.

\newpage
\section{Definici\'on del Problema}

El problema \emph{Vehicle Routing Problem} nace de la necesidad de tener el manejo efectivo de la provisi\'on de bienes o servicios, ya sea en la
o retiro de estos en distintos puntos geogr\'aficos, dada el inmenso crecimiento de las ciudades y de la poblaci\'on se hacia imposible generar
rutas \'optimas en tiempos lo suficientemente acotados, como para tener un mejor manejo de los recursos disponibles. Se ha demostrado que de acuerdo
aplicaciones del mundo real que una buena planeaci\'on de los procesos de distribuci\'on genera ahorros del 5\% al 20\% en los costos de transporte
global.
\newline
El problema \emph{VRP} es un problema cl\'asico de optimizaci\'on combinatoria con m\'ultiples aplicaciones.
Este consiste en general en lo siguiente:
\begin{itemize}
 \item Un dep\'osito central
 \item Clientes que requieren que se les entregue productos, los cuales tienen cierta demanda.
 \item Una flota de veh\'iculos disponibles para realizar las entregas.
 \item Se requiere la planeaci\'on para la entrega de productos a los consumidores.
 \item Se necesita m\'inimizar los costos de transporte para la entrega de los productos, sean los costos: distancia de cada circuito, n\'umero de
 veh\'iculos utilizados, tiempo de transporte, etc.
 \'item Generar las rutas necesarias para la entrega de todos los productos a los clientes.
\end{itemize}
De acuerdo a lo anterior, se puede apreciar cuales son las variables, restricciones, etc.
Primero se tienen las constantes, las que son la cantidad de veh\'iculos y su capacidad.
Las variables, son todos aquellos clientes que necesitan que se les entreguen productos, ademas del deposito central, si bien este no tiene demanda, pero si tiene una distancia asociada a cada ciudad.
Las restricciones en este caso, es la capacidad que tiene que cada veh\'iculo, dado que los veh\'iculos no pueden entregar m\'as productos que su m\'axima capacidad.
La funci\'on de evaluaci\'on es tener la m\'inima distancia que cumpla la entrega para cada cliente, tomando en cuenta cada veh\'iculo.
\newline
Para describir los tour que se generan para cada veh\'iculo, se describen mediante grafos, cada nodo es un cliente y los arcos son el camino que 
tiene asociado cada tramo. Adem\'as cada arco tiene asociado un costo.
\newline
\subsection{Variantes del Problema}
Existen m\'ultiples variables a este problema, a continuaci\'on se describen, cabe destacar que este problema dada su complejidad es mas d\'ificil que el TSP que es muy parecido.


\subsubsection{Traveling Salesman Problem (TSP)}

El problema del vendedor viajero es uno de los problemas m\'as estudiados, 
este problema responde a la pregunta, que dada una lista de ciudades 
junto con las distancias de esta, ?` Cual es la ruta mas corta posible 
para visitar cada ciudad exacedemos con elogios solamente! es hora de dar el gran salttamente una vez, y regresar a la ciudad de origen?. 
Este es un problema NP-duro ~\cite{TSP} adem\'as de ser netamente combinatorio. 
Porque mencionar este problema, dado que se puede decir que
es el problema madre para \emph{VRP}, pr\'acticamente es el mismo salvo que para el 
\emph{TSP} solo es un veh\'iculo, por ende se puede encontrar mucha m\'as literatura para 
la resoluci\'on de este problema, no se ha ahondara m\'as dado que abarca demasiado y solo 
es \'util su menci\'on y en que consiste.
\newline
Del \emph{TSP} se desprenden adem\'as variantes a este problema, que en este caso conviene 
mencionarlos igualmente dada su similitud con el \emph{VRP} ~\cite{TSP}

\begin{itemize}
 \item Traveling Salesman Problem with Backhauls (TSPB)
 \item Traveling Salesman Problem with Time Windows (TSPTW)
 \item Multiple Traveling Salesman Problem (MTSP)
\end{itemize}

En general todas variaciones anteriores se aplican de una manera al \emph{VRP}, dado que el \emph{TSP} no es lo que se quiere explicar, no hay necesidad de
detallar mas las variantes, de este.

\subsubsection{Capacitated Vehicle Routing Problem (CVRP)}
Esta variaci\'on al igual que el problema estudiado es una flota de veh\'iculos de reparto con una capacidad uniforme, los cuales 
tienen que atender la demanda conocida de cliente, en distintos puntos geogr\'aficos, satisfaciendo la restricci\'on de que las rutas descritas tienen
que ser a un m\'inimo costo tal cual lo har\'ia el \emph{VRP}, con la salvedad de que la capacidad de cada veh\'iculo es 
uniforme de una sola mercader\'ia~\cite{CVRP}.
\newline
El objetivo de esta variaci\'on del problema es que se quiere reducir al m\'inimo posible la flota de los veh\'iculos de reparto, adem\'as 
de la suma de los tiempos de viaje, considerando tambi\'en de que la capacidad de cada veh\'iculo no puede ser excedida por la ruta a tomar.
Su formulaci\'on es la misma que para el \emph{VRP} agregando la restricci\'on de que la demanda total de los clientes en una misma ruta
no debe sobrepasar la capacidad del veh\'iculo asignado a la misma.


\subsubsection{Distance Constrained Vehicle Routing Problem (DCVRP)}

Esta variante del problema radica en que a diferencia del \emph{Capacitated Vehicle Routing Problem (CVRP)} aqu\'i la restricci\'on de la capacidad
del veh\'iculo es cambiada por la distancia ~\cite{TSP} en que se tiene que hacer el recorrido, dado que existe un limite m\'aximo el cual 
tiene que tener la ruta. Sigue teniendo m\'ultiples veh\'iculos, punto de salida y final el mismo, etc.
Aqu\'i usualmente el costo se relaciona directamente con el viaje realizado o con el tiempo de este.


\subsubsection{Vehicle Routing Problem with Backhauls (VRPB)}

La variante \emph{VRPB} tambi\'en conocida como linehault-backhault problem, tiene la particularidad que un cliente, puede estar satisfecho o no
con el producto que se le entrega, dada esta premisa, este podr\'a devolver o no el producto al veh\'iculo repartidor ~\cite{Prosser93Hybrid}, 
dada esta problem\'atica
es que se incorporan como restricciones el contenedor del veh\'iculo como algo dimensional, ya que es necesario saber la capacidad 
de este adem\'as 
de si es necesario reordenar la carga, para as\'i poder llevar todo nuevamente al dep\'osito ~\cite{Prosser93Hybrid}, sin que el veh\'iculo se quede sin capacidad en alg\'un 
momento.

\subsubsection{Vehicle Routing Problem with Time Windows (VRPTW)}

El \emph{VRPTW} se diferencia con los antecesores en que aqu\'i existe un periodo de tiempo en el cual el veh\'iculo debe iniciar el recorrido para
cada cliente, para as\'i llegar sin problemas en el tiempo esperado por el cliente ~\cite{journals/eor/AziGP07}.
Esta variante adem\'as toma en consideraci\'on, de que si el veh\'iculo llega antes del tiempo estimado, debe esperar un tiempo t para que empiece
nuevamente el servicio, de manera que los plazos se cumplan cabalmente. Unas de sus aplicaciones son para el encaminamiento del autob\'us escolar y
la programaci\'on de lineas a\'ereas.
\newpage

\subsubsection{Vehicle Routing Problem with Pickup and Delivery (VRPPD)}

Aqu\'i lo que se modela es que cada cliente pide una cierta cantidad de productos, los cuales tienen que ser recogidos en el almac\'en, para luego ser
llevados por el veh\'iculo hasta el cliente. Cada veh\'iculo tiene una capacidad de carga, por lo que los productos deben caber dentro del veh\'iculo
para as\'i poder ser entregados al cliente, aqu\'i el problema es mucho mas realista en algunos puntos, al igual que sus antecesores se debe considerar 
la ruta, los clientes, y adem\'as poder minimizar los costos, ya sea ruta mas corta, cantidad de veh\'iculos empleados, para as\'i poder satisfacer 
la demanda de los clientes.
~\cite{EilamTzoreff2002193}.

\newpage
\section{Estado del Arte}

El problema \emph{VRP} en un problema NP-dif\'icil , esto quiere decir que es un problema que intuitivamente es al menos tan dif\'icil como cualquier 
problema NP. El \emph{VRP}, es una variante mas compleja del TSP.
\newline
Actualmente la literatura se encuentra mucha informaci\'on de este problema, siendo las variantes expuestas en la \emph{Definici\'on del Problema }, las mas ocurrentes, dado que se centran en la problem\'atica de hoy en d\'ia, en cuanto a la entrega de productos mediante la v\'ia de 
medios de transporte.
El \emph{VRP} es uno de los problemas m\'as comunes y m\'as estudiados, dada su derivaci\'on del \emph{TSP}, su evoluci\'on hist\'orica data del a\~no 1956 hasta los trabajos mas recientes. El \emph{VRP}, se conoce como tal desde el a\~no 1959 \cite{Ing3832}, el cual se modela la entrega de combustible a trav\'es de una flota de camiones.
\newline
En un principio el problema se intento solucionar aplicando t\'ecnicas completas de b\'usqueda, en las cuales destacan Programaci\'on Lineal y Entera, su principal problema fue el tiempo de computa que tardaban en entregar una soluci\'on\cite{Ing3832}. Luego se utilizaron Heur\'isticas, en las cuales su principal caracter\'isticas es que era m\'etodos constructivos de b\'usqueda de soluci\'on, la problem\'atica que surgi\'o a partir de estos, es que generaban buenas rutas en un inicio, pero el final no era el mejor\cite{Ing3832}. Por \'ultimo lo ultimo en usar fueron las Metaheur\'isticas. Estas se han utilizado en el \'ultimo tiempo, junto con la inclusi\'on de nuevos cambios como que los par\'ametros solo son conocidos durante el tiempo de ejecuci\'on\cite{Ing3832}.
\newline
En cualquier t\'ecnica que se utilice, la representaci\'on que mas frecuentemente se utilizo, es la de arboles, en la cual cada nodo
(ciudad) se conecta con otra mediante una arista (arco o camino recorrido), para la conexi\'on entre todas las ciudad se utiliza 
un grafo, en la cual matriz de adyacencia es la representaci\'on mas utilizada, dada su facilidad de manejo y simplicidad de
implementar.
A continuaci\'on se presentan algoritmos mas actuales los cuales tratan de encontrar soluci\'on a estas problem\'aticas:
\subsection{Algoritmo Gen\'etico}
Los Algoritmos gen\'eticos, son m\'etodos adaptativos que se basan en el proceso gen\'entico de los organismos vivos, que se usan para resolver 
problemas de b\'usqueda y optimizaci\'on. Estos tratan de emular la evoluci\'on natural, actuando con el principio de sobrevivencia del mas apto, 
mejorando as\'i el desempe\~no de individuos que sean mejores que sus antepasados. La aptitud de los individuos se mide a trav\'es de una funci\'on de
evaluaci\'on o funci\'on de aptitud, para que ver que tan aptos son. Se genera una poblaci\'on inicial, los cuales compiten por la oportunidad de
reproducirse, pasando sus aptitudes a la siguiente generaci\'on. Para la reproducci\'on el algoritmo utiliza ciertos operadores, los cuales entregan 
una mejor opci\'on para evolucionar en una buena soluci\'on.\cite{whitepaper}
\begin{itemize}
 \item Selecci\'on: Se busca dentro de la poblaci\'on o se seleccionan \emph{X} cantidad de individuos, y se ve cuales son los mas aptos para ir al 
 siguiente paso del algoritmo, el valor que dice si son aptos o no, es la funci\'on de aptitud el cual es la m\'etrica para saber si 
 son seleccionados o no.\cite{whitepaper}
 \item Crossover: Aqu\'i mediante una probabilidad, se ve si los individuos previamente seleccionados son cruzados entre si, para dar origen a sus,
 hijos existen varios operadores de cruce, los cuales pueden ser, cruzamiento en un punto, dos puntos, etc, esto depender\'a del 
 tipo de implementaci\'on utilizada. Dando as\'i mejores individuos, que heredaran las caracter\'isticas de sus padres.\cite{whitepaper}
 \item Mutaci\'on: Este operador introduce un cambio aleatorio en los individuos, la gracia de este operador, es que entrega nueva informaci\'on a la 
 poblaci\'on, por ende permite mejorar y dar saltos de un lugar de b\'usqueda a otro. Para la utilizaci\'on de este operador, se usa un probabilidad 
 la cual dir\'a si el operador se usara en el individuo o no.\cite{whitepaper}
\end{itemize}
\subsection{Hill Climbing}
El algoritmo Hill Climbing se basa en la b\'usqueda de profundidad, lo que se hace es que en cada paso se mejora la soluci\'on encontrada, de manera 
de incrementar la posibilidad de encontrar la cima.
El algoritmo se basa los siguientes pasos\cite{HC}:
\begin{itemize}
 \item Construir una soluci\'on inicial, que cumpla con las restricciones del problema
 \item Tomar la soluci\'on inicial o actual y construir un vecindario a partir de un movimiento.
 \item Evaluar el vecindario generado a partir de la soluci\'on actual y el movimiento, para luego tomar el mejor de estos
 \item Repetir el proceso hasta no tener mejores soluciones.
\end{itemize}
Para evaluar la calidad de las soluciones generadas se utiliza una funci\'on de evaluaci\'on.
Existen varias variaciones del algoritmo, pero en general esta es la mas sencilla y es la base para los otros.

\subsection{Tabu Search}
El Tabu Search es muy parecido al m\'etodo anterior, con la salvedad de que continue una lista tab\'u, la cual impide que el movimiento que genero el
vecino de mejor calidad sea utilizado en la siguiente iteraci\'on, asi impide que se generen ciclos, los cuales dejar\'ian estancado al algoritmo.
\newline
El largo de la lista permite la intensificaci\'on y la diversificaci\'on.
\subsection{Simulated Annealing}
Al igual que el algoritmo Gen\'etico, este m\'etodo mejora las soluciones con el tiempo. Su nombre proviene del proceso por el cual se enfr\'ian
los metales, lentamente, para obtener una estructura molecular cohesionada y resistente, dado que mediante imitando este proceso se desea encontrar
soluciones.
\newline
Se determina una soluci\'on inicial y se permite un grado alto de movimiento por el espacio de las soluciones, buscando por todo el espacio de 
b\'usqueda. A medida que avanza el proceso, se van permitiendo movimientos cada vez m\'as peque\~nos, hasta que se converge a una soluci\'on final. 
Esto es, que los movimientos iniciales son grandes y dirigidos a zonas donde la funci\'on objetivo es alta, y a medida que se converge, 
dichos movimientos son m\'as acotados.
Para esto se necesita ~\cite{whitepaper}:
\begin{itemize}
 \item Una descripci\'on de las soluciones posibles.
 \item Un generador de cambios aleatorios entre las soluciones.
 \item Una funci\'on objetivo para las soluciones.
 \item Un par\'ametro de control T y una asignaci\'on de enfriamiento que describe como var\'ian los par\'ametros con el tiempo.
\end{itemize}

En primer lugar, se debe contar con una soluci\'on inicial, sobre la cual se aplicar\'an ciertos movimientos que generar\'an un vecindario de soluciones, las cuales ser\'an comparadas con la soluci\'on inicial, si alguna presenta de estas tiene alguna mejora reemplazara a la soluci\'on inicial dependiendo de una probabilidad de aceptaci\'on, el proceso se repite tantas veces sea necesario en un tiempo determinado.

\newpage
\section{Modelo Matem\'atico}
La formulaci\'on aqu\'i presentada se centra en programaci\'on binaria.~\cite{RUTEO}

\subsection{Par\'ametros}

\begin{enumerate}[(1)]
 \item G = (V,A), grafo completo no dirigido.
 \item $V$ $=$ $\{v_{0},v_{1},v_{2},...,v_{n}\}$ Conjunto de nodos, $v_{0}$ es el dep\'osito
 \item $A$ $=$ $\{(i,j)$ $:$ $i,j$ $\in$ $V$, $i\neq j\}$ Conjunto de Aristas.
 \item $d_{i}$ $=$ demanda del nodo i.
 \item $k$ N\'umero de veh\'iculos disponibles.
 \item $Q$ capacidad de los veh\'iculos
 \item $C_{i,j}$ Costo en ir desde el nodo i al nodo j
\end{enumerate}
\begin{itemize}
\item Los par\'ametros (1),(2),(3) y (4) dado que estos valores son constantes se tiene un grafo el cual contenta un conjunto de Nodos V los que son las ciudades(clientes) mas el deposito el cual sera el primer nodo. El conjunto de aristas A es el cual cada ciudad esta conectada entre si, sin haber una arista que se conecte con el mismo nodo, o sea no hay un camino que interconecte a un nodo consigo mismo.
\item El par\'ametro (4) indica cual es la demanda de cada nodo (cliente) que debe ser satisfecha.
\item El par\'ametro (5) indica la cantidad de veh\'iculos que se tienen en la flota, para satisfacer a los clientes.
\item La capacidad que tiene cada veh\'iculo es la misma para todos, la que se refleja en el par\'ametro (6).
\item El camino que tiene que recorrer un veh\'iculo desde una ciudad a otra tiene un costo de distancia, el que se ve reflejado en el par\'ametro (7)
\end{itemize}
\subsection{Variables}
Se usara una variable binaria para las decisiones 
\begin{center}
\begin{equation}
	X_{i,j}= \begin{cases} 1, & \text{si la soluci\'on utiliza el arco(\emph{i,j})} \\ 0, & \text{si no} \end{cases}
\end{equation}

\end{center}

\subsection{Restricciones}

\begin{align}
 &\displaystyle\sum_{i \in V}X_{i,j} = 1, \forall j \in V_{0} \\
 &\displaystyle\sum_{j \in V}X_{i,j} = 1, \forall i \in V_{0} \\
 &\displaystyle\sum_{i \in V}X_{i,0} = k \\
 &\displaystyle\sum_{i \in V}X_{0,j} = k \\
 &\displaystyle\sum_{i \not\in S}\sum_{j \in S}X_{x,i} \geq r(S), \forall S \subset V/\{0\}, S \neq \Phi  \\
 &X_{i,j} \in {0,1}, \forall i,j \in V
\end{align}

\begin{enumerate}
 \item Las restricciones (1) y (2) son para que no se repitan los arcos en las soluciones. Dado que solo se debe visitar una sola vez cada ciudad, por ende no pueden haber soluciones con un camino repetido.
 \item Las restricciones (3) y (4) son para que entren y salgan la misma cantidad de veh\'iculos al deposito. El nodo 0, se toma como el deposito por esta raz\'on cualquier  camino hacia el nodo i debe terminar en 0, y
 cualquier camino que termine en el nodo j debe llegar a 0
 \item La restricci\'on (5) no permite la existencia de substours.
 \item r(S) es el n\'umero m\'inimo de veh\'iculos necesarios para satisfacer la demanda de S. en Donde S es un subconjunto de nodos V menos el nodo deposito dado que este no tiene demanda. 
 La cantidad S es distinta a $\Phi$, que es la demanda total del circuito\cite{Toth2002487}.
 
 
\end{enumerate}

\subsection{Funci\'on objetivo}

\begin{center}
$Min$ $\displaystyle\sum_{i \in V}\sum_{j \in V} C_{i,j}*X_{i,j}$
\end{center}
\begin{itemize}
 \item Lo que se quiere es minimizar los costos asociados a los caminos hechos. Por esta raz\'on a cada variable X, se le multiplica su costo, y la sumatoria de todo da la funci\'on objetivo
\end{itemize}

\newpage
\section{Representaci\'on}
%Representaci\'on matem\'atica y estructura de datos que se usa (arreglos, matrices, etc.),
%por qu\'e se usa, la relaci\'on entre la representaci\'on matem\'atica y la estructura.
Dado el modelo propuesto anteriormente, la representaci\'on mas intuitiva que se encontr\'o para las conexiones entre las ciudades y el deposito es una matriz de \emph{NxN}, 
en donde N es la cantidad de ciudades en cada instancia. En \emph{C++} esto se logra mediante un arreglo bidimensional. En cada celda \emph{i,j} de la matriz se almacenara la distancia de la
ciudad \emph{i} a la ciudad \emph{j}. La celda \emph{(0,0)} es la que contiene el deposito, si bien es cierto no necesariamente el deposito esta en el principio de las ciudades, para simplificar 
se usa de esta manera, dado que las distancias se calculan a partir de la posici\'on de estos. Otro dato a considerar, es que esta es una matriz sim\'etrica en donde su diagonal son \emph{0}, dado 
que el ir desde una ciudad a la misma no tiene costo. A continuaci\'on se muestre un ejemplo:

\begin{center}
 \begin{tabular}[t]{|c|c|c|c|c|}
\hline
           & Deposito & Cliente 1 & Cliente 2 & Cliente 3 \\
\hline
Deposito   & 0        & 2        & 5        & 1\\
\hline
Cliente 1   & 2        & 0        & 4        & 6\\
\hline
Cliente 2   & 5        & 4        & 0        & 3\\
\hline
Cliente 3   & 1        & 6        & 3        & 0\\
\hline
\end{tabular}

\end{center}
\begin{center}
\textbf{Ejemplo} Matriz de adyacencia. 
\end{center}
Como se ve, el ir del deposito a la ciudad 1 tiene un costo de 2 (matriz[0][2] = 2), y de la ciudad 1 a la ciudad 3 tiene un costo de 6 (matriz[1][3] = 6).
\newline
Una vez que se tiene la matriz de adyacencia es necesario ir almacenando las rutas que sigue cada veh\'iculo, es por esta raz\'on que la estructura que se utilizo es el vector, dada su rapidez 
a la hora de hacer operaci\'on sobre este.

\begin{center}
 \begin{tabular}[t]{|c|c|c|c|c|}
\hline
 Deposito & Cliente 4 & Cliente 2 & Cliente 3 & Deposito \\
\hline

\end{tabular}
\end{center}
\begin{center}
\textbf{Ejemplo} Vector de rutas. 
\end{center}

Para almacenar los datos correspondientes, como demanda de la ciudad, distancia, etc. se almaceno dentro de nodo del vector un objeto con los datos de cada ciudad, de esta manera se sabe el orden 
con cual se visitaron las ciudades.
\begin{center}
 \begin{tabular}[t]{|c|}
\hline

 Ciudad \\
 \hline
Datos \\
\hline
+Set() \\
+Get() \\
\hline
 \end{tabular}
\end{center}

\begin{center}
\textbf{Ejemplo} Clase Ciudad. 
\end{center}

Dado que los par\'ametros son conocidos antes del tiempo de ejecuci\'on se tiene que para estos solo se usaron variables globales. Las cuales son.
\begin{center}
 \begin{itemize}
 \item \emph{DIM}: Dimensi\'on de la matriz.
 \item \emph{k}: N\'umero de veh\'iculos disponibles.
 \item \emph{Q}: Capacidad de los veh\'iculos.
 \end{itemize}
\end{center}
\begin{center}
\textbf{Ejemplo} constantes. 
\end{center}




\newpage

\section{Descripci\'on del algoritmo}
%C\'omo fue implementada la soluci\'on. Interesa la implementaci\'on m\'as que el algoritmo gen\'erico, es decir,
%si se tiene que implementar SA, lo que se espera es que se explique en pseudoc\'odigo la estructura
%general y en p\'arrafo explicativo c\'omo fue implementada cada parte para su problema particular. Si
%se utilizan operadores se dede justificar por qu\'e se utilizaron dichos operadores. Si fuera el caso de una
%t\'ecnica completa, describir detalles relevantes del proceso, si se utiliza recursi\'on o no, etc.
%En este punto no se espera que se incluya c\'odigo, eso va aparte.

El algoritmo que se uso para resolver este problema fue \emph{Minimal Forward Checking (MFC)}. La implementaci\'on de MFC fue realizada en \emph{C++}.

\begin{algorithm}
  \caption{
    Minimal Forward Checking}
  \begin{algorithmic}[1]
       \STATE{$DIM \gets Inicializar$}
       \STATE{$k \gets Inicializar$}
       \STATE{$Q \gets Inicializar$}
       \STATE{matriz $\gets Inicializar$}
       \STATE{LlenarMatriz(matriz)}
       \STATE{<<vector>>$Ruta_{k}$ $\gets Inicializar$}
       \STATE{<<vector>>Visitadas $\gets Inicializar$}
       \STATE{Ruta$\gets$Deposito}
       \REPEAT
        \FOR{$i < Q$}
	  \STATE{Ruta_{i}$\gets$Deposito}
	  \Function{MFC}{matriz,Ruta$_{i}$,Visitadas}
	    \REPEAT
	      \STATE{Encontrada $\gets$BuscarCiudadCercana(matriz,\'ultima ciudad en la ruta)}
	      \IF{((Vehiculo$_{i}$-DemandaEncontrada$>$0)\&\&(Encontrada no este en visitadas))}
	       \STATE{Ruta$_{i} \gets$ Encontrada}
	       \STATE{Visitadas$\gets$Encontrada}
	       \STATE{CapacidadVehiculo$_{i}\gets$(CapacidadVehiculo$_{i}$-DemandaEncontrada)}
	      \ENDIF
	    \UNTIL{Vehiculo en la Ruta$_{i}$ tenga capacidad}
	    \RETURN Ruta$_{i}$,Visitadas
	    \EndFunction
          \STATE{\emph{i++}}
          \ENDFOR
        \UNTIL{CriterioParada}
        \end{algorithmic}
\end{algorithm}
A continuaci\'on se detalle el funcionamiento de cada parte, para lograr entender de mejor manera su funcionamiento.
\newpage
\subsection{Inicializaci\'on de la Variables}

Al inicio del algoritmo se deben ejecutar todas aquellos par\'ametros que se deben saber para el correcto funcionamiento, dado que esto se sabe con anterioridad al tiempo de generaci\'on de soluciones. 
Por esta raz\'on es que la Dimensi\'on de la matriz, el numero de veh\'iculos y la capacidad de estos, es lo primero en inicializar. El problema que se ve tiene como requerimiento que estos par\'ametros sean
establecidos antes, no durante el transcurso de b\'usqueda de soluciones.
Luego se inicializa la matriz, la cual tendr\'a como dimensiones el numero de ciudades m\'as el deposito que ocupara el lugar (0,0). La matriz se llena a continuaci\'on con las distancias entre cada ciudad.
Como se dijo anteriormente, se inicializan el vector de las ciudades visitadas, mas 1 vector por cada veh\'iculo, para luego en el vector de rutas, ingresar el deposito en cada uno, dado que como condici\'on
se debe partir de este. No se ingresa en el vector de visitadas el deposito puesto que es el \'unico punto que se debe visitar 2 veces, tanto como al inicio como al fin de cada ruta.

\begin{algorithm}
  \caption{
    Minimal Forward Checking-Inicializaci\'on}
  \begin{algorithmic}[1]
       \STATE{$DIM \gets Inicializar$}
       \STATE{$k \gets Inicializar$}
       \STATE{$Q \gets Inicializar$}
       \STATE{matriz $\gets Inicializar$}
       \STATE{LlenarMatriz(matriz)}
       \STATE{<<vector>>$Ruta_{k}$ $\gets Inicializar$}
       \STATE{<<vector>>Visitadas $\gets Inicializar$}
       \STATE{Ruta$\gets$Deposito}
        \end{algorithmic}
\end{algorithm}

\subsection{Filtrado}

\begin{algorithm}
  \caption{
    Minimal Forward Checking - Filtrado}
  \begin{algorithmic}[1]
       \REPEAT
        \FOR{$i < Q$}
	  \STATE{Ruta_{i}$\gets$Deposito}
	  \Function{MFC}{matriz,Ruta$_{i}$,Visitadas}
	    \REPEAT
	      \STATE{Encontrada$\gets$BuscarCiudadCercana(matriz,\'ultima ciudad en la ruta)}
	      \IF{((Vehiculo$_{i}$-DemandaEncontrada$>$0)\&\&(Encontrada no este en visitadas))}
	       \STATE{Ruta$_{i} \gets$ Encontrada}
	       \STATE{Visitadas$\gets$Encontrada}
	       \STATE{CapacidadVehiculo$_{i}\gets$(CapacidadVehiculo$_{i}$-DemandaEncontrada)}
	      \ENDIF
	    \UNTIL{Vehiculo en la Ruta$_{i}$ tenga capacidad}
	    \RETURN Ruta$_{i}$,Visitadas
	    \EndFunction
          \STATE{\emph{i++}}
          \ENDFOR
        \UNTIL{CriterioParada}
        \end{algorithmic}
\end{algorithm}

Como es un algoritmo de b\'usqueda completa una de los principales problemas es ver el resultado en un tiempo acotado, suponiendo instancias demasiado grande, en el cual no hay un tiempo polinomial asociado 
al computo se estable un criterio de parada, ya sea un tiempo especificado, cantidad de soluciones encontradas, etc.
\newline
Luego para cada veh\'iculo Q se hace la b\'usqueda de soluciones, para continuar e ingresar en su ruta el deposito.
La funci\'on MFC toma como par\'ametros la matriz de adyacencia de las ciudades, la Ruta para el veh\'iculo $i$, y el listado de ciudades visitadas. Dado que en la propuesta del problema la gran restricci\'on
es que se debe satisfacer la demanda, y no hay problema entre las ciudades (todas interconectadas) salvo que no se pueden visitar mas de una vez, lo que se busca es que el veh\'iculo entrege la mayor cantidad
de productos (satisfaga la mayor cantidad de clientes posible), por este motivo se tiene que el procedimiento se repita hasta que no el cami\'on se quede sin capacidad.
\newline
Luego dentro de la funci\'on como se tiene que el primero en la ruta es el deposito se busca la ciudad mas cercana y se almacena en una variable, esta variable contiene toda la informaci\'on de la ciudad 
encontrada. No se hace mayor incapie en la funci\'on BuscarCiudadCercana dado que el lector puede implementarla a gusto, dado que solo entrega esto, y la manera de implementaci\'on no afecta en mayor cantidad 
el grueso del \emph{MFC}.
\newline
La condicion \emph{if} lo que busca es chequear que la ciudad encontrada respete las restricciones, las cuales son que la demanda que tiene dicha ciudad pueda ser satisfecha por la capacidad que le queda al
veh\'iculo, y adem\'as que la ciudad no este en la lista de visitadas, as\'i de esta manera no se caigan en un loop ya sea porque el veh\'iculo tiene capacidad infinita o siempre se va a la misma ciudad.
\newline
Una vez dentro del \emph{if} se procede a hacer las asignaciones, se ingresa dentro de la ruta la ciudad encontrada, y adem\'as en el vector de visitadas para as\'i asegurar el correcto funcionamiento. 
Como ultima asignaci\'on a la capacidad del veh\'iculo se le resta la demanda de la ciudad encontrada.
\newline
La funci\'on finalmente entrega ruta obtenida y las ciudades visitadas. Se entrega las visitadas, dado que este es un valor que se tiene que guardar en el tiempo para todos los veh\'iculos. Luego se incrementa 
$i$ que es lo que pasa de un veh\'iculo a otro.
\newline
Para no incurrir en errores, se debe tener en cuenta que cada asignaci\'on de ciudad que se hace o guarde es un objeto, esto se aplica para todos los vectores y comparaci\'on entre ciudad cercana viable y
ciudades en ruta o en el vector de visitadas.


\newpage
\section{Experimentos}
%Se necesita saber c\'omo experimentaron, c\'omo definieron par\'ametros, c\'omo los fueron modificando, cu\'ales 
%problemas/instancias se trataron y por qu\'e, etc.
Para los experimentaci\'on se utilizo un Computador AMD con 4 Core de 3.6 GHz, 8 GB de RAM y Ubuntu Linux 13.10 de 64bit.
\new line
Las instancias utilizadas son las de Christofides, las que se proporcionaron en la pagina del ramo (moodle.inf.utfsm.cl, Curso IA). Las instancias proporcionadas cuentas con distinta cantidad de veh\'iculos, capacidad de estos, dimensiones y costos para cada ciudad. Inclusive otros par\'ametros como lo son tiempo de servicio de cada cliente, para simplicidad solo se tomaron algunos factores, los cuales son los mencionados con anterioridad en este paper (veh\'iculos, capacidad de veh\'iculos, cantidad de ciudades). Una de las importancias que tienen estas instancias, es que incluyen la informaci\'on del mejor tiempo obtenido.
\newline
Independiente de los valores entregados en cada instancia, se variaron algunos par\'ametros para ver el rendimiento del algoritmo y ver como funciona en los distintos escenarios.
\newline
	Las instancias que se utilizaron inclu\'ian los siguientes par\'ametros:
	\begin{itemize}
		\item COMMENT: Mejor Tiempo obtenido en cada instancia.
		\item DIMENSION: Cantidad de ciudades m\'as el deposito (dimension de la matriz).
		\item VEHICLES: Cantidad de veh\'iculos para la instancia.
		\item CAPACITY: Corresponde a la capacidad de cada veh\'iculo.		
		\item NODE\_COORD\_SECTION valor1 valor2 valor3: Valor 1 corresponde al n\'umero de la ciudad, valor 2 es la coordenada X que tiene y valor 3 es la coordenada y de la ciudad.
		\item DEMAND\_SECTION valor1 valor2: Valor 1 corresponde al n\'umero de la ciudad y el valor2 corresponde a la demanda de aquella ciudad.
		\item DEPOT\_SECTION valor1 valor2: corresponde a la ubicaci\'on del deposito, el valor1 corresponde a la coordenada x y el valor2 corresponde a la coordenada y del deposito.
	\end{itemize}
	
	\subsection{Instancias de Prueba}
	
Las instancias de prueba que se tienen variaban con entre los siguientes par\'ametros:

	\begin{itemize}
		\item DIMENSION: La dimesion variaba desde los 51 hasta las 200 ciudades, iban tomando valores intermedios.
		\item VEHICLES: La cantidad de veh\'iculos que variaban en las instancias iban desde 5 a 17. Independiente de los valores pre-establecidos se uso desde 1 veh\'iculo para probar la eficiencia.
		\item CAPACITY: La capacidad vario desde 140 hasta 200 siendo 200 el valor mas recurrente.
		\item DEMAND\_SECTION valor1 valor2: Valor 1 corresponde al n\'umero de la ciudad y el valor2 corresponde a la demanda de aquella ciudad.
	\end{itemize}
	En general se usaron la instancia de dimension 51, dado que para las otras instancias no entrego resultados. Por lo que la variaci\'on de esta fue principalmente la capacidad de los veh\'iculos y la cantidad de estos, teniendo en cuenta que el valor mas critico fue el de 3 veh\'iculos, ya que una mayor cantidad de estos no entrega resultado.

\newpage
\section{Resultados}
%Qu\'e fue lo que se logr\'o con la experimentaci\'on, incluir tablas y gr\'aficos (lo m\'as explicativo posible).
%Los resultados deben ser comentados en esta secci\'on.
A continuaci\'on se detallan los resultados obtenidos, teniendo como referencia los parametros de la dimensi\'on y la cantidad de veh\'iculos.
\subsection{Variaci\'on de Veh\'iculos.}
En esta parte se hace la prueba con la variaci\'on de veh\'iculos para cada instancia:
\begin{center}
 \begin{tabular}[t]{|c|c|c|c|}
\hline
Veh\'iculos & Dimensi\'on & Distancia Total Recorrida 1 & Tiempo de ejecuci\'on \\
\hline
1   		& 51         & 700     &  1615,14[s] \\
\hline
2           & 51        & 900     &   2365,56[s]\\
\hline
2           & 51        & -     &   -\\
\hline
4           & 51        & -     &  - \\
\hline
5           & 51       & -     &  - \\
\hline
\end{tabular}
\end{center}
Se observa bien que para una cantidad mayor de 2 veh\'iculos el algoritmo no responde, dado que al buscar todas las combinaciones posibles no hay un tiempo razonable. Sin embargo para uno o 2 la distancia total recorrida es considerable, pensando que para esta instancia se tiene una distancia m\'inima 524,61


\subsection{Variaci\'on de la dimensi\'on.}
\begin{center}
 \begin{tabular}[t]{|c|c|c|c|}
\hline
Veh\'iculos & Dimensi\'on & Distancia Total Recorrida 1 & Tiempo de ejecuci\'on \\
\hline
1   		& 51         & 700     &  1615,14[s] \\
\hline
1           & 151        & 1564     &   3456,12[s]\\
\hline
1           & 200        & -     &   -\\
\hline
2           & 51        & 900     &  2365,56[s] \\
\hline
2           & 151       & -     &  - \\
\hline
2           & 200       & -     &  - \\
\hline
3           & 51       & -     &  - \\
\hline
3           & 151       & -     &  - \\
\hline
3           & 200       & -     &  - \\
\hline
\end{tabular}
\end{center}

Dado que se observa que para una cantidad de veh\'iculos superior a 2 no hay una soluci\'on entregada, por lo que se opta por cantidades peque\~nas de veh\'iculos en cada una de las distintas matrices, se observa que para dimensiones por sobre 151 tampoco existen resultados.
\newpage
\section{Conclusiones}
\begin{itemize}
 \item El problema de \emph{Vehicle Routing Problem}, es una problem\'atica actual de la industria, por lo que encontrar soluciones acorde a las necesidades de los clientes y proveedores, no es una tarea f\'acil, inclusive dada la complejidad que este tipo de problemas puede tener, es por ello que a trav\'es de la aparici\'on de t\'ecnicas para resolver estos problemas se han usado todo tipo de metaheur\'isticas inclusive t\'ecnicas completas, siendo las metahuristicas las que llevan una mayor ventaja, dado la entrega de soluciones en tiempos acotados, como por ejemplo si necesito el reparto para el d\'ia siguiente, no puedo computar 1 semana una buena soluci\'on.
 \item Dada su similitud con el \emph{TSP}, el modelo matem\'atico que se presenta es muy parecido, con lo que no hay problema entre la relaci\'on establecida con anterioridad, es por esta raz\'on que el modelo descrito es acorde al problema y relaciona ambos problemas, por ende el modelo con el tiempo no ha variado mucho, m\'as que nada en las distintas versiones del problema se incluyen o eliminan restricciones, como dimensiones del veh\'iculo, si en cada entrega hay o no un tiempo de espera, etc. Por ende siempre que se busca el modelo de esto se tienen muchas similitudes, inclusive con la modelaci\'on de los problemas m\'as recientes.
 
 \item La representaci\'on utilizada ayuda mucha a la hora de ejecutar los c\'alculos y las iteraciones para poder generar rutas factibles, dado que la implementacion de listas multiplemente enlazadas genera mucho problema para la mantencion de esta, mientras que un grafo es la representaci\'on mas utilizada en las art\'iculos, y con justa raz\'on.
 
 \item En general todas las t\'ecnicas han ido resolviendo el mismo problema, inclusive con los par\'ametros y restricciones nuevas, teniendo en cuenta que cada vez que se implemento alguna t\'ecnica estas difer\'ian en el tiempo de entrega de una soluci\'on de buena calidad o que problemas tra\'ia una por sobre otra, como se explico t\'ecnicas constructivas ten\'ian la problem\'atica de que en un inicio las rutas ten\'ian mejor calidad que las ultimas.
 
 \item Existe una fase de transici\'on en la cual un problema con cierta cantidad de restricci\'on es mas facil de solucionar que uno sin muchas restricciones, en la cual este es el caso de que no hay muchas restricciones por lo que se hace muy dif\'icil encontrar una soluci\'on en poco tiempo por la consideraci\'on de que todas las ciudades estan conectadas con las dem\'as, y la restricci\'on mas fuerte es la capacidad de cada veh\'iculo
 
 \item Dado que se utiliza un t\'ecnica completa es dificil ver en que pueden diferenciar con metahur\'isticas, dado que el MFC es un t\'ecnica completa y por ende al variar los par\'ametros siempre se tendr\'an todas las soluciones y no se podr\'a comparar salvo en tiempos de entrega, que para este caso fueron demasiado altos, teniendo en cuenta las dimensiones a explorar y que por sobre todo es un grafo fuertemente conectado. 
 
 \item Dada la complejidad del problema, se puede encontrar amplia literatura acerca de este, sobre todo algoritmos relativamente nuevos, dado que es un problema muy complejo de resolver, no se utilizan t\'ecnicas completas en la actualidad, dado que se necesitan buenas soluciones en tiempos acotados (resoluci\'on en tiempo polinomial), a futuro se ve cambios en mutaci\'on entre t\'ecnicas, para ver las calidades de las soluciones implementadas, al igual que inclusi\'on de otras variables, en estos tiempos el cambio din\'amico de veh\'iculos, capacidad de estos o inclusive la devoluci\'on de productos, son los casos de estudio que actualmente se ven, y como las diferentes t\'ecnicas reaccionan frente a estos.
 \end{itemize}

\newpage
\section{Bibliograf\'ia}
\bibliographystyle{plain}
\bibliography{Referencias}

\end{document} 